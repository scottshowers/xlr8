"""
Parser Code Generator for Intelligent Parsing
Generates custom Python parser code based on PDF structure analysis

Author: HCMPACT
Version: 1.0
"""

import logging
from typing import Dict, Any, List
from datetime import datetime

logger = logging.getLogger(__name__)


class ParserCodeGenerator:
    """
    Generates executable Python parser code based on PDF structure analysis.
    
    Creates custom parsers that are optimized for specific document types.
    """
    
    def __init__(self):
        self.templates = self._load_templates()
    
    def generate(self, structure_analysis: Dict[str, Any], pdf_path: str, sample_output: Dict[str, Any] = None) -> str:
        """
        Generate parser code based on structure analysis.
        
        Args:
            structure_analysis: Output from PDFStructureAnalyzer
            pdf_path: Path to PDF (for metadata)
            sample_output: Optional sample output to guide generation
            
        Returns:
            Complete Python code as string
        """
        
        logger.info(f"Generating parser code for: {structure_analysis.get('document_type', 'unknown')}")
        
        # Select template based on document type and strategy
        doc_type = structure_analysis.get('document_type', 'unknown')
        strategy = structure_analysis.get('recommended_strategy', 'pdfplumber')
        
        # Generate code
        code = self._generate_parser_code(structure_analysis, pdf_path, sample_output)
        
        return code
    
    def _load_templates(self) -> Dict[str, str]:
        """Load code generation templates."""
        
        return {
            'header': '''"""
Custom PDF Parser - Auto-generated by XLR8 Intelligent Parser
Generated: {timestamp}
Document Type: {doc_type}
Strategy: {strategy}
Confidence: {confidence:.1%}

This parser was automatically generated based on PDF structure analysis.
"""

import pymupdf
import pdfplumber
import pandas as pd
from typing import Dict, Any, List
import logging

logger = logging.getLogger(__name__)


class CustomParser:
    """Auto-generated custom parser for specific document structure."""
    
    def __init__(self):
        self.parser_version = "1.0.0"
        self.generated_date = "{timestamp}"
        self.confidence = {confidence}
    
''',
            
            'pdfplumber_table': '''    def parse(self, pdf_path: str) -> Dict[str, Any]:
        """Parse PDF using pdfplumber (table-focused)."""
        
        logger.info(f"Parsing with pdfplumber: {{pdf_path}}")
        
        tables = []
        text_content = ""
        
        try:
            with pdfplumber.open(pdf_path) as pdf:
                for page_num, page in enumerate(pdf.pages):
                    # Extract tables
                    page_tables = page.extract_tables()
                    
                    for table in page_tables:
                        if table and len(table) > 1:  # Has header + data
                            # Convert to DataFrame
                            df = pd.DataFrame(table[1:], columns=table[0])
                            
                            # Clean DataFrame
                            df = self._clean_dataframe(df)
                            
                            tables.append({{
                                'page': page_num + 1,
                                'data': df,
                                'rows': len(df),
                                'columns': len(df.columns)
                            }})
                    
                    # Extract text
                    page_text = page.extract_text()
                    if page_text:
                        text_content += page_text + "\\n"
            
            return {{
                'success': True,
                'tables': tables,
                'text': text_content,
                'method': 'pdfplumber_custom',
                'confidence': self.confidence
            }}
            
        except Exception as e:
            logger.error(f"Parse error: {{e}}")
            return {{
                'success': False,
                'tables': [],
                'text': '',
                'error': str(e)
            }}
    
    def _clean_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """Clean extracted DataFrame."""
        
        # Remove empty columns
        df = df.dropna(axis=1, how='all')
        
        # Remove empty rows
        df = df.dropna(axis=0, how='all')
        
        # Reset index
        df = df.reset_index(drop=True)
        
        # Strip whitespace from string columns
        for col in df.columns:
            if df[col].dtype == 'object':
                df[col] = df[col].astype(str).str.strip()
        
        return df
''',
            
            'pymupdf4llm': '''    def parse(self, pdf_path: str) -> Dict[str, Any]:
        """Parse PDF using pymupdf4llm (text-focused)."""
        
        logger.info(f"Parsing with pymupdf4llm: {{pdf_path}}")
        
        try:
            import pymupdf4llm
            
            # Extract markdown
            md_text = pymupdf4llm.to_markdown(pdf_path)
            
            # Convert markdown tables to DataFrames
            tables = self._extract_tables_from_markdown(md_text)
            
            return {{
                'success': True,
                'tables': tables,
                'text': md_text,
                'method': 'pymupdf4llm_custom',
                'confidence': self.confidence
            }}
            
        except Exception as e:
            logger.error(f"Parse error: {{e}}")
            return {{
                'success': False,
                'tables': [],
                'text': '',
                'error': str(e)
            }}
    
    def _extract_tables_from_markdown(self, md_text: str) -> List[Dict[str, Any]]:
        """Extract tables from markdown text."""
        
        tables = []
        
        # Simple markdown table detection
        lines = md_text.split('\\n')
        in_table = False
        table_lines = []
        
        for line in lines:
            if '|' in line:
                if not in_table:
                    in_table = True
                    table_lines = []
                table_lines.append(line)
            else:
                if in_table and table_lines:
                    # Convert to DataFrame
                    df = self._markdown_table_to_df(table_lines)
                    if df is not None:
                        tables.append({{
                            'data': df,
                            'rows': len(df),
                            'columns': len(df.columns)
                        }})
                    in_table = False
                    table_lines = []
        
        return tables
    
    def _markdown_table_to_df(self, lines: List[str]) -> pd.DataFrame:
        """Convert markdown table to DataFrame."""
        
        if len(lines) < 2:
            return None
        
        # Parse header
        header = [c.strip() for c in lines[0].split('|') if c.strip()]
        
        # Parse data rows (skip separator line)
        data = []
        for line in lines[2:]:
            row = [c.strip() for c in line.split('|') if c.strip()]
            if row:
                data.append(row)
        
        if not data:
            return None
        
        return pd.DataFrame(data, columns=header)
''',
            
            'footer': '''
# Convenience function
def parse_pdf(pdf_path: str) -> Dict[str, Any]:
    """Parse PDF using custom parser."""
    parser = CustomParser()
    return parser.parse(pdf_path)
'''
        }
    
    def _generate_parser_code(self, analysis: Dict[str, Any], pdf_path: str, sample_output: Dict[str, Any] = None) -> str:
        """Generate complete parser code."""
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        doc_type = analysis.get('document_type', 'unknown')
        strategy = analysis.get('recommended_strategy', 'pdfplumber')
        confidence = analysis.get('confidence', 0.5)
        
        # Start with header
        code = self.templates['header'].format(
            timestamp=timestamp,
            doc_type=doc_type,
            strategy=strategy,
            confidence=confidence
        )
        
        # Add parsing method based on strategy
        if strategy == 'pdfplumber' or strategy == 'camelot':
            code += self.templates['pdfplumber_table']
        elif strategy == 'pymupdf4llm':
            code += self.templates['pymupdf4llm']
        else:
            # Default to pdfplumber
            code += self.templates['pdfplumber_table']
        
        # Add footer
        code += self.templates['footer']
        
        return code
    
    def save_parser(self, code: str, output_path: str) -> bool:
        """
        Save generated parser code to file.
        
        Args:
            code: Generated Python code
            output_path: Path to save to
            
        Returns:
            True if successful
        """
        
        try:
            with open(output_path, 'w') as f:
                f.write(code)
            
            logger.info(f"Saved parser to: {output_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error saving parser: {e}")
            return False
    
    def test_generated_parser(self, code: str, pdf_path: str) -> Dict[str, Any]:
        """
        Test generated parser code.
        
        Args:
            code: Generated parser code
            pdf_path: PDF to test on
            
        Returns:
            Test result dictionary
        """
        
        try:
            # Create a temporary module
            import sys
            from types import ModuleType
            
            # Create module
            temp_module = ModuleType('temp_parser')
            
            # Execute code in module namespace
            exec(code, temp_module.__dict__)
            
            # Get parser class
            CustomParser = temp_module.CustomParser
            
            # Test parsing
            parser = CustomParser()
            result = parser.parse(pdf_path)
            
            return {
                'success': True,
                'result': result,
                'tables_found': len(result.get('tables', [])),
                'text_length': len(result.get('text', '')),
                'method': result.get('method', 'unknown')
            }
            
        except Exception as e:
            logger.error(f"Error testing parser: {e}")
            return {
                'success': False,
                'error': str(e)
            }


# Convenience function
def generate_parser(structure_analysis: Dict[str, Any], pdf_path: str) -> str:
    """
    Quick parser generation.
    
    Args:
        structure_analysis: PDF structure analysis result
        pdf_path: Path to PDF
        
    Returns:
        Generated Python code
    """
    generator = ParserCodeGenerator()
    return generator.generate(structure_analysis, pdf_path)
